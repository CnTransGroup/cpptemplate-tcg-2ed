# 函数模板

本章介绍函数模板。函数模板通过参数化参数表示一个函数族。

## 1.1 概览
函数模板为不同的类型提供了相同的函数行为。换句话说，函数模板表征了一个函数族。这种表示就像普通函数一样，除了元素的类型通过参数来表示。让我们来看一个简单的示例。

### 1.1.1 定义模板
下面的函数是一个函数模板，返回两个值中的较大值：
```cpp
// basics/max1.hpp
template<typename T>
T max(T a, T b) {
    // if b < a then yield a else yield b
    return b < a ? a : b;
}
```
这个模板定义了一个函数族用来求两个值中较大的。值的类型作为模板参数 T。如例子中所示，模板参数表示方法为：
`template< comma-separated-list-of-parameters >`

这个例子中，参数列表为 `typename T`。注意，这个列表是通过尖括号括起来。关键字 `typename` 引入了*类型参数*。在 C++ 程序中这是最常见的模板参数，当然也有其他类型，我们在第三章中讨论。

现在，类型参数是 T。你可以使用任何 identifier 作为参数名称，T 只是约定俗成

### 1.1.2 使用模板

### 1.1.3 两阶段转换

## 1.2 模板参数推导

## 1.3 多个模板参数

### 1.3.1 返回类型模板参数

### 1.3.2 推导返回类型

### 1.3.3 Common Type 作为返回类型


## 1.4 默认模板参数

## 1.5 重载函数模板

## 1.6 但是，我们不应该？

### 1.6.1 按值还是按引用传参？

### 1.6.2 为什么不用 inline？

### 1.6.3 为什么不用 constexpr？

## 1.7 总结
- 函数模板定义了不同模板参数的函数族
- 当函数参数以来模板参数时，函数模板会推导对应的参数类型
- 你可以显式限定模板参数
- 你可以定义模板参数的默认值。而且可以是更前面没有默认值的模板参数
- 你可以重载函数模板
- 当重载函数模板时，你需要确保只有一个函数可以匹配到调用方
- 当重载函数模板时，显式限制你的修改
- 确保编译器可以在调用前知道所有函数模板